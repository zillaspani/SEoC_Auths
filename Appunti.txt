##########################################
Registrazione delle Thing
Ogni Thing deve essere registrata per utilizzare l'infrastruttura software che permetterà autenticazione e registrazione.
Lo scopo della fase di registrazione sarà quella di generere delle credenziali (una chiave crittografica) tra Auth e Thing.
Inoltre, durante tale processo verranno scambiate informazioni quali i rispettivi ID, requisiti di sicurezza richiesti ed offerti rispettivamente
ed eventuali policy di comunicazione.

###Thing CON supporto crittografia a chiave pubblica###:
Se la Thing è in grado di utilizzare la crittografia asimmetrica a chiave pubblica, Thing e Auth dovranno utilizzare le rispettive
chiavi pubbliche per concordare la chiave simmetrica (SESSION_KEY) per le successive comunicazioni.


La Thing che vuole registrasti ad una Auth, invia un messaggio all'Auth REGISTER_TO_AUTH cifrato con la chiave pubblica dell'Auth.

REGISTER_TO_AUTH From Thing to Auth
{
  "MESSAGE_TYPE": 0,
  "THING_ID": "thing_hostname",
  "ADDRESS":"thing_ip_address",
  "PORT":"thing_port",
  "SEC_REQ": {number to specify security requirements}
  "THING_SIGNATURE": "E[(THING_ID | ADDRESS | PORT | SEC_REQ),thing private key]"
}

Ricevito il messaggio, l'Auth lo decifra con la sua chiave privata ed effettua le seguenti verifiche nel seguente ordine:
-Verifica della THING_SIGNATURE con la chiave pubblica della Thing.
-Veririfica se essa è in grado di fornire i requisiti di sicurezza richiesti dalla Thing SEC_REQ
-Verifica se possiede risorse disponibili per gestire la Thing.

Se le verifiche hanno esito positivo, l'Auth invia un messaggio REGISTER_RESPONSE alla thing, cifrato con la chiave pubblica della Thing, in
cui verrà allegata la SESSION_KEY per le comunicazioni successive e un A_NONCE per evitare eventuali reply attack. 

REGISTER_RESPONSE (Esito Positivo) From Auth to Thing
{
  "MESSAGE_TYPE": 1,
  "AUTH_ID": "auth_hostname",
  "ADDRESS":"auth_ip_address",
  "PORT": "auth_port",
  "A_NONCE": {auth_nonce},
  "ACCEPTED": 1,
  "SESSION_KEY": "session_key"
}

Se la SECONDA e TERZA veririfica falliscono, l'Auth invia un messaggio REGISTER_RESPONSE alla thing, cifrato con la chiave pubblica della thing, in
cui vi saranno:
- A_NONCE per evitare eventuali reply attack. 
- Una lista di Auth suggerite a cui successivamente la Thing dovrà provare a registrarsi. 
REGISTER_RESPONSE (Esito Negativo) From Auth to Thing
{
  "MESSAGE_TYPE": 1,
  "AUTH_ID": "auth_hostname",
  "ADDRESS":"auth_ip_address",
  "PORT": "auth_port",
  "A_NONCE": {auth_nonce},
  "ACCEPTED": 0,
  "SUGGESTED_AUTH":{
    "suggested_auth_hostname":{
      "ADDRESS":"suggested_auth_ip_address",
      "PORT": "suggested_auth_ip"
    }
  }
}

Se la PRIMA verifica fallisce, il tutto viene ignorato senza fornire alcuna risposta.


###Thing CON supporto crittografia a chiave pubblica###:

Se la Thing, non possiede nessun meccanismo a chiave pubblica, verrà utilizzata una chiave simmetrica inizialmente settata dal gestore, che verrà
utilizzata per il primo scambio di messaggi per generare la SESSION_KEY.

Se lo scambio di messaggi avviene tra un Auth e una Thing che non possiede nessun meccanismo di sicurezza a chiave pubblica, al posto di questa viene utilizzata
una cosiddetta "TMP_KEY". Cioè una chiave che è conosciuta in anticipo dalla Thing e dall'Auth. Nella fattispecie:
-REGISTER_TO_AUTH sarà cifrato con tale TMP_KEY, non possederà nessuna signature, ma bensì una marca temporale.

REGISTER_TO_AUTH From Thing to Auth
{
  "MESSAGE_TYPE": 0,
  "THING_ID": "thing_hostname",
  "ADDRESS":"thing_ip_address",
  "PORT":"thing_port",
  "SEC_REQ": {number to specify security requirements}
  "TIME_STAMP": {time_stamp}
}

L'Auth verifica se il TIME_STAMP è non superiore a 600 secondi dalla momento della ricezione della TMP_KEY.
Successivamente l'Auth effettua le seguenti verifiche:
-Veririfica se essa è in grado di fornire i requisiti di sicurezza richiesti dalla Thing SEC_REQ
-Verifica se possiede risorse disponibili per gestire la Thing.

Se queste vanno a buon fine, all'interno di REGISTER_RESPONSE cifrato con la TMP_KEY, vi sarà la SESSION_KEY.
Se invece, queste non vanno a buon fine, verrà inviata una REGISTER_RESPONSE cifrata con la TMP_KEY contenente una lista di Auth a cui tentare la registrazione.


##########################################
Comunicazioni tra Things e Auths

-Processo di autorizzazine delle Things.
Le Thing autenticate possono cominicare tra di loro tramite una SESSION_KEY_T[X] (Chiave di sessione tra la thing e la thingX) ottenuta tramite le rispettive Auth.
Il processo di autorizzazine inizia con un messaggio CONNECT_TO_AUTH, cifrato con la SESSION_KEY tra Auth e thing inviato da una thing alla propria Auth di competenza.

CONNECT_TO_AUTH From Thing to Auth
{
  "MESSAGE_TYPE": 2,
  "THING_ID": "thing_hostname",
}

L'auth che riceve il messaggio CONNECT_TO_AUTH, una volta decifrato con la SESSION_KEY appartente alla specifica thing, risponde
con un ACK, definito di seguito come AUTH_HELLO.

AUTH_HELLO From Auth to Thing
{
  "MESSAGE_TYPE": 3,
  "AUTH_ID": "auth_hostname",
  "A_NONCE": {auth_nonce}
}

All'interno di AUTH_HELLO, vi sarà un nonce, necessario ad evitare attacchi di tipo reply.

Di seguito, la thing invierà un messaggio cifrato con la SESSION_KEY detto SESSION_KEY_REQUEST, formato:

SESSION_KEY_REQUEST From Thing to Auth
{
  "MESSAGE_TYPE": 4,
  "THING_ID": "thing_hostname",
  "A_NONCE": {auth_nonce_from_AUTH_HELLO_MESSAGE},
  "T_NONCE": {thing_nonce},
  "WHO": [
    "thingX_hostname it wants to communicate with",
    .
    .
    "thingN_hostname it wants to communicate with"
  ]
}

All'interno troveremo, i due nonce, A_NONCE dovrà essere uguale al NONCE scambiato nel messaggio precedente, mentre T_NONCE è necessario per evitare evenentiali reply attack verso l'Auth.
Inoltre, vi sarà un array WHO, cioè una lista di thing_hostname tramite il quale la thing esprime la volontà di voler ottenere delle chiavi di sessione, 
per avviare delle comunicazioni con le things specificate.
Sarà cura dell'Auth, contattare le Auth di competenza a cui appartengono le things specificate in WHO, per generare, concordare e distribuire le chiavi tra le thing. 
($$$$$$$) QUI ENTRA IN GIOCO RELAZIONE DI FIDUCIA TRA AUTH ($$$$$$$)

SESSION_KEY_RESPONSE From Auth to Thing
{
  "MESSAGE_TYPE": 5,
  "AUTH_ID": "hostname",
  "A_NONCE": {auth_nonce},
  "SESSION_KEYS": {
    "thingX_hostname" : "session_key between requesting thing and thing X",
    .
    .
    "thingN_hostname" : "session_key between requesting thing and thing N" 
  }
}

SESSION_KEY_RESPONSE è la risposta dell'Auth, all'interno del quale vi sono i campi:
-A_NONCE per reply attack;
-Una lista di coppia <thing_hostname,session_key> , in questa lista vi saranno solo le coppie riguardanti entità per cui,
è stato possibile negoziare una chiave.

RELAZIONE DI FIDUCIA:
Supponiamo io sia l'Auth A1 di T1. T1 vuole comunicare con T3, che è di competenza di A3.
É lecito chiedersi, posso generare una chiave e la invio ad A3 che a sua volta dovrà inviarla ad T3? Se c'è fiducia sicuramente :D

##########################################
Comunicazioni tra Things

Quando una Thing riceve una chiave di sessione per comunicare un'altra Things, questa può iniziare
una comunicazione con quest'ultima. Tale comunicazione, a seguito da una challenge-response sarà autenticata e crifrata.
Ma vediamo nel dettaglio:

COMM_INIT_REQUEST From thing1 to thing2
{
  da definire
}

COMM_INIT_RESPONSE From thing2 to thing1

COMM_INIT_FINAL From thing1 to thing2

COMUNICAZIONEEEEEEEEE LET'S GOOOO

##########################################

Comunicazioni tra Auth
Le Auth cominicano tra di loro per lo scambio delle chiavi di sessione necessarie alle comunicazioni tra Things.
In primo luogo, l'Auth 1 viene contattata da una Thing, sia questa Thing 1, che richiede la generazione di una chiave di sessione per comunicare con Thing 2.
Individuata l'Auth di competenza, sia questa Auth 2, l'Auth 1 calcola il grado di fiducia. Questo può essere definito:
-Grado di fiducia diretto
-Grado di fiducia indiretto
-Grado di fiducia del canale
- Altre metriche che saranno proprio il core dell'analisi :Da

Se il grado di fiducia è soddisfacente, l'Auth provvede ad inviare due massaggi:

- SESSION_KEY_RESPONSE a Thing1, cifrata con la chiave di sessione tra Auth1 e Auth2, in cui vi sarà la chiave
di sessione per comunicare con thing2.

AUTH_SESSION_KEYS From Auth1 to Auth 2, cifrata con chiave pubblica di Auth2 
{
  "MESSAGE_TYPE": 6,
  "AUTH_ID": "hostname",
  "A_NONCE": "{auth_nonce}",
  "SESSION_KEYS": {
    "thingX_hostname" : "session_key for comminications between thingX and thing Y"
  }
}

Auth 2 a sua volta, aggiorna le chiavi di Thing 2 con un messaggio UPDATE_KEYS

UPDATE_KEYS from Auth2 to Things1
{
  "MESSAGE_TYPE": 7,
  "AUTH_ID": "hostname",
  "A_NONCE": "{auth_nonce}",
  "SESSION_KEYS": {
    "thingX_hostname" : "session_key for comminications between thingX and thing Y"
  }
}

#####Processo di autorizzazione completo#####

Il processo di autorizzazine inizia con un messaggio CONNECT_TO_AUTH, cifrato con la SESSION_KEY tra Auth e thing inviato da una Thing alla propria Auth di competenza.

L'Auth che riceve il messaggio CONNECT_TO_AUTH, una volta decifrato con la SESSION_KEY appartente alla specifica thing, risponde
con un ACK, definito di seguito come AUTH_HELLO.

Di seguito, la thing invierà un messaggio cifrato con la SESSION_KEY detto SESSION_KEY_REQUEST, in cui esprimerà la volonta di voler comunicare con alcune Things.

Sarà cura dell'Auth, contattare le Auth di competenza a cui appartengono le things specificate nel campo WHO del messaggio SESSION_KEY_REQUEST, per generare, concordare e distribuire le chiavi tra le thing. 
Nella fattisoecie:
SESSION_KEY_RESPONSE è la risposta dell'Auth verso la Thing che ha richiesto le chiavi, all'interno del quale vi saranno le chiavi di sessioni che è stato possibile generare.
AUTH_SESSION_KEYS è l'invio delle chiavi generate all'Auth delle Things con cui la Thing voleva parlare.


